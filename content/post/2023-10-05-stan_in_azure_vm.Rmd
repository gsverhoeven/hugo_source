---
title: 'Rstudio & Stan on a shoestring in the cloud using Azure-CLI'
author: "Gertjan Verhoeven"
date: '2023-09-21'
summary: Setting up A Linux Stan development environment on Azure.
slug: azure-stan-linux
draft: no
categories:
- Linux
- Statistics
tags:
- R
- cmdstanr
baseurl: https://gsverhoeven.github.io
header:
  image: headers/bb_heatmap_banner.png
  preview: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Time to explore what the cloud is all about, in particular what is called **Infrastructure as code**.
Our goal is to write code (i.e. scripts) using open-source tools to automatically set up cloud infrastructure.

For this I chose a specific use case, which is **spinning up a data analysis development environment with R, Rstudio and Stan tools** installed and configured. 

This has two big advantages, **reproducibility** and **lower switching cost**: 

* Scripting the compute resources that made a data analysis possible is the next level in reproducibility. 
* Ideally, we want our scripts to be independent of a particular cloud provider. This would allow us to easily change from e.g. Azure to Amazon AWS if things stagnate or we can get a better deal elsewhere.

After weighing my options, I chose to write Linux shell scripts that use Azure-CLI to deploy Linux Ubuntu VMs that are configured using Cloud-init. While doing so I discovered that being able to test changes locally first before deploying to the cloud speeds up development significantly. 

To summarize and motivate the tech choices I made:

* I chose **Azure** since my employer recently moved to Azure and me learning it would be beneficial for work.
* I chose **Azure-CLI** to avoid the additional abstraction layer introduced by more generic tools like **Terraform/OpenTofu** or **Ansible**
* I chose **Linux Ubuntu OS** to keep cost down, as it is free and needs less resources than **Windows 10/11**
* I chose **Cloud-init** as it appears to be an emerging standard to configure Linux cloud images
* I chose the **QEMU emulator** to run VMs locally to speed up development

The blog uses Linux throughout, but as it uses Azure-CLI it should work for Windows as well.

# Setting up our local IaaS dev environment

As mentioned above, we use both **Azure-CLI** and **QEMU virtual emulator** for local VM development.
My local desktop system is Ubuntu 18.04 LTS.

## Using Azure CLI to connect with Azure and execute commands

We start with creating a free account on Azure. This comes with 200 Euro free credit to spent within a month.

First we need to install `azure-cli`:

```
#downloads the signing key from Microsoft
curl -sL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null 
## creates a file called microsoft.gpg in the folder where keys are stored

AZ_REPO=$(lsb_release -cs) ## outputs the codename for the linux distribution i.e. Ubuntu 18.04 = bionic
echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $AZ_REPO main" | sudo tee /etc/apt/sources.list.d/azure-cli.list 
## writes that URL to the package resource list
sudo apt-get update
sudo apt-get install azure-cli
```

First time we need to login to Azure and choose a subscription:
```
# Log in interactively.
az login
```

Test if it works by creating and deleting a new resource group:

```
az group create --location westeurope --resource-group MyCoolRG

az group delete --resource-group MyCoolRG
```

## QEMU virtualizer

Next we install **QEMU**. The documentation for Cloud-init contains a [section on how to work with QEMU](https://cloudinit.readthedocs.io/en/23.3.3/tutorial/qemu.html).

QEMU on ubuntu can be used as virtualiser in collaboration with KVM kernel components. In that case it uses the hardware virtualisation technology to virtualise guests. Using KVM, one can run multiple virtual machines running unmodified Linux or Windows images. Each virtual machine has private virtualized hardware: a network card, disk, graphics adapter, etc. 

Install QEMU:
```
sudo apt install qemu-kvm
```
This installs QEMU 2.11 (2018) that plays well with Ubuntu 18.04.

QEMU threw an error 
https://16shuklarahul.medium.com/how-to-fix-kvm-permission-denied-error-on-ubuntu-18-04-16-04-14-04-f04a6e23c0cd

Use the adduser command to add your user to the kvm group.

```
sudo adduser gertjan kvm
```

On my machine, all users in group `kvm` have `rw` access for `/dev/kvm`.

```
qemu-system-x86_64 --version

QEMU emulator version 2.11.1(Debian 1:2.11+dfsg-1ubuntu7.41)
Copyright (c) 2003-2017 Fabrice Bellard and the QEMU Project developers
```

https://askubuntu.com/questions/213512/buffer-i-o-error-on-device-fd0-logical-block-0-error


testing with QEMU first for the cloud-init part.

Here is example code that download a Cloud-init enabled Ubuntu 22.04 image (`jammy`) that we use for local testing.
The initial disk size of the image is 2.2 GB, which is too small to install all the software we need to run Rstudio.
So we increase the image size to 30GB.

```
wget https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img
qemu-img info jammy-server-cloudimg-amd64.img 
# 2.2 GB
qemu-img resize jammy-server-cloudimg-amd64.img 30G

qemu-system-x86_64                                            \
    -net nic                                                    \
    -net user
    -machine accel=kvm:tcg                                      \ # use hardware acceleration
    -cpu host                                                   \ # emulate host processor
    -m 1024                                                      \ # use 1 GB RAM
    -nographic                                                  \ # graphic window disabled
    -hda jammy-server-cloudimg-amd64.img                        \ # Set a virtual hard drive and use the specified image file 
    -smbios type=1,serial=ds='nocloud;s=http://10.0.2.2:8000/'
```

```
ubuntu@jammy:~$ sudo lsblk -d | grep disk
fd0     2:0    1     4K  0 disk 
sda     8:0    0    30G  0 disk 
```

I ended up writing a script `do_qemu.sh` that starts a local VM using the cloud-config YAML file that is also used to configure the Azure VM.

# Azure cloud in a nutshell

Azure is organized as a hierarchical structure. See the schematic below.
All the components that make up the infrastructure are called *resources*.
**Resources** are contained within **resource groups**.
**Resource groups** exist within a **subscription**.
Finally, **subscriptions** exist within **management groups**.

![](azure_scope-levels.png)

# Our Azure Infrastructure

In this blog post, we will create the infrastructure from scratch.
Our infrastructure consists of a single virtual network that contains a single VM.
The VM will be configured to be accessible through the internet using SSH and "Microsoft Remote Desktop"(RDP).

To quickly create a virtual machine (VM) in Azure, it is possible to use a single Azure CLI command with default values that automatically creates any required supporting resources.
This however, does not lead to understanding how all the parts add up and depend on one another.
I therefore decided to **create each Azure resource separately**.
In doing so we gradually build up the infrastructure step by step.
(An official Azure tutorial by Cynthia Nottingham and others that takes a similar approach can be found [here](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/create-cli-complete))

Special attention is given to secure our network and VM, because it is exposed to the public internet.
Hackers are continuously scanning the Azure network IP address ranges for vulnerable systems, so we need to defend ourselves.
We use a basic Firewall called "Network Security Group" that works with **Security Rules**.
More on our security measures below.

I chose not to use an "Availability Set" as this only makes sense for groups of VMs.

We use Linux shell **Environment Variables** to separate the actual resource configuration choices (which image, which VM type etc) from the actual Azure CLI commands that create the resources.

# Step-by-step resource creation

* First we create a new **Resource group**
* Then we create a **Virtual Network** with a **Subnet**
* Then we create a **Public IP**
* Then we create a **Network Security Group** & Rules
* Then we create a **Network Interface Card (NIC)**

## Create resource Group

Within this subscription, we create a *Resource Group*, `myRG2`. 

This needs a location, Since I am in West europe, let's choose westeurope.

```
# create shell variables
resourceGroup=myRG2
location=westeurope
az group create --name $resourceGroup --location $location
az group show --resource-group myRG2
```

## Create Virtual Network

https://learn.microsoft.com/en-us/cli/azure/azure-cli-vm-tutorial-2

Next we create a Virtual Network and a Subnet: 

```
# create shell variables
vnetName=StanDEV-VNet1
subnetName=StanDEV-Subnet1
vnetAddressPrefix=10.0.0.0/16
subnetAddressPrefix=10.0.0.0/24

az network vnet create \
  --name $vnetName \
  --resource-group $resourceGroup \
  --address-prefixes $vnetAddressPrefix \
  --subnet-name $subnetName \
  --subnet-prefixes $subnetAddressPrefix
```

## Create Public IP address

Now let's create a public IP address with `az network public-ip create`. 
Public IP addresses come in two different flavours (or "SKU"s , stock keeping units).

**Standard** which is better than **Basic**. 
We use **standard**, as its the default and its better.
This always results in a static IP address.

*Standard SKU: Secure by default model and be closed to inbound traffic when used as a frontend. Allow traffic with network security group is required (for example, on the NIC of a virtual machine with a Standard SKU public IP attached).*

```
publicIP=TEST-public-ip
mypublicdns=gsverhoeven

az network public-ip create \
    --resource-group $resourceGroup \
    --name $publicIP \
    --dns-name $mypublicdns
```

This public IP address enables you to connect to your VMs from the Internet. 

This results in a Fully qualified domaine name `fqdn` of `gsverhoeven.westeurope.cloudapp.azure.com`

```
nslookup  gsverhoeven.westeurope.cloudapp.azure.com
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	gsverhoeven.westeurope.cloudapp.azure.com
Address: 68.219.248.112
```

```
az network public-ip list -o table
```

```
Name            ResourceGroup    Location    Zones    Address        IdleTimeoutInMinutes    ProvisioningState
--------------  ---------------  ----------  -------  -------------  ----------------------  -------------------
TEST-public-ip  myRGtest         westeurope           104.46.41.142  4                       Succeeded

```

## Create network security group & Rules

To control the flow of traffic in and out of your VMs, apply a **network security group** to a virtual NIC or subnet. The following example uses `az network nsg create` to create a network security group named `myNetworkSecurityGroup`:

```
NetworkSecurityGroup=myNSG

az network nsg create \
    --resource-group $resourceGroup \
    --name $NetworkSecurityGroup
```

You define rules that allow or deny specific traffic. 

**To allow inbound connections on port 22 (to enable SSH access)**, create an inbound rule with `az network nsg rule create`. The following example creates a rule named `myNetworkSecurityGroupRuleSSH`:

```
az network nsg rule create \
    --resource-group myResourceGroup \
    --nsg-name myNetworkSecurityGroup \
    --name myNetworkSecurityGroupRuleSSH \
    --protocol tcp \
    --priority 1000 \
    --destination-port-range 22 \
    --access allow
```

To allow **Remote Desktop traffic** to reach your Linux VM, add another network security group rule.
The following example creates a rule named `myNetworkSecurityGroupRuleRDP`:

```
az network nsg rule create \
    --resource-group $resourceGroup \
    --nsg-name $NetworkSecurityGroup \
    --name myNetworkSecurityGroupRuleRDP \
    --description "Allow RDP at port 3389" \
    --direction Inbound \
    --protocol tcp \
    --priority 1001 \
    --destination-port-range 3389 \
    --access allow
```

Examine the network security group and rules with `az network nsg rule list`:

```
az network nsg rule list --resource-group myRG --nsg-name StanDEV-nsg --output table
```

## Create NIC

Virtual network interface cards (NICs) are programmatically available because you can apply rules to their use. 
In the following `az network nic create` command, you create a NIC named `myNic` and associate it with your network security group. The public IP address `myPublicIP` is also associated with the virtual NIC.

```
az network nic create \
    --resource-group $resourceGroup \
    --name $NICName \
    --vnet-name $vnetName \
    --subnet $subnetName \
    --public-ip-address $publicIP \
    --network-security-group $NetworkSecurityGroup
```

From the dependencies, we can see that a NIC ties together:

* A Network Security Group, 
* A public IP,
* A VNet & subnet

All within a resource group. Later on, when we create the VM, we only need to specify the NIC to bring up the VM in the virtual network with the desired NSG.

## VM Image choice

As VM image I chose **Ubuntu Server 22.04 LTS** for reasons already mentioned above.
But which one, how do we find the image we need?

Canonical, the company behind Ubuntu Linux, offers various preconfigured Ubuntu images in the Azure Marketplace.
Azure-CLI can be used to programmatically interact with Azure Marketplace. I used [this blog post by Joshua Powers](https://powersj.io/posts/ubuntu-images-azure/) to learn how this works.

All images published by Canonical are discoverable using the following command:

```
az vm image list-skus \
--publisher Canonical \
--offer Ubuntu \
--location westeurope \
-o table
```

I went with `22_04-lts`. 

## VM Size choice

There is a bewildering amount of choice regarding [different types of VMs offered by Microsoft]((https://azure.microsoft.com/en-us/pricing/details/virtual-machines/series/
). As my focus is on cheap, general purpose compute, I ended up with D-series VMs.

To have a reasonable fast software install I found we need at least 8GB of mem and 2 vCPUs, this corresponds to `Standard_D2s_v3`. With this VM, cloud-init installation finishes after 23 min, after which the VM is fully operational.

https://azureprice.net/vm/Standard_D2s_v3?currency=EUR&timeoption=day&paymentType=payasyougo


```
`Standard` is recommended tier.
D – General purpose compute
2 – VM Size
s – Premium Storage capable
v3 – version
```


## Disk storage associated with the VM

When an Azure virtual machine is created, two disks are automatically attached to the virtual machine.

The disk that holds the VM image (in our case Ubuntu 22) is called the **OS disk**. In Azure, the [default OS disk size for Linux VMs](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/expand-disks?tabs=ubuntu) is 30 GB. This appears to also be the minimum OS disk size, there is only the option to expand them. The OS disk is labeled `/dev/sda` by default.

In addition, there is a temp disk mounted that is physically located on the Azure host where the VM is running. This can only be used for temporary data processing, and its size is given. It does not incur any extra cost. Temporary disks are labeled `/dev/sdb` and have a mountpoint of `/mnt`. More info on temp disks [here](https://www.cloudelicious.net/azure-vms-and-their-temporary-storage/)

I did not go so far as to attach a data disk. So we need to make sure that work we do on the VM is pushed to e.g. Github, because if we tear the VM down, the user data is lost as well.

The Disk types are controlled by the `-storage-sku` option when we create the VM.
Allowed values for this option include `Standard_LRS` for traditional hard disks (HDD), `StandardSSD_LRS` and `Premium_LRS` both consists of SSD disks but with differing performance characteristics. Locally redundant storage (LRS) replicates your data three times within a single data center in the selected region. More info at [Azure disk types](https://learn.microsoft.com/en-us/azure/virtual-machines/disks-types)

We want the cheapest SSD option, this seems to be `StandardSSD_LRS`.

## Create the VM

We now are ready to bring it all together and create the VM. For this Azure-CLI has the `az vm create` command. 
The following example creates a VM that automatically starts up:

```
az vm create \
  --resource-group $resourceGroup \
  --name $vmName \
  --nics $NICName \
  --image $vmImage \
  --storage-sku $storagetype \
  --size $vmSize \
  --admin-username $AdminUsername \
  --custom-data $customDataScript.tmp \
  --generate-ssh-keys \
  --output $azOutput \
  --security-type Standard # no trusted launch
```

Most options we already discussed above, except two:
* `--custom-data`, this specifies the **Cloud-init** script that will passed on to the cloud-init enabled VM image and contains instructions to create user accounts, install packages etc. More below. 
* `--generate-ssh-keys`, this is described below under "Securing the VM".

Although there are Azure-cli commands to stop, start and dellocate the VM, I typically use a shell script `deploy_vm_ubuntu.sh` to bring it up, leave it running while I need it, and then tear it down using another script `delete_vm_ubuntu.sh`. This script simply uses `az group delete` to remove the Resource group containing the VM and related resources.

# Securing our VM

For a VM with a public IP on the hostile internet, we need some security measures in place.
"Hackers" will be using a list of azure IPs and will attempt brute force SSH to gain access.
See for example this [post](https://superuser.com/questions/1112092/hacking-attempts-to-linux-vm-in-azure) on superuser.com.

We take the following steps to secure our VM from outside attacks:

* All inbound traffic ports are closed using Azure NSG except SSH and RDP (detailed above)
* SSH password authentication is disabled, access only through SSH keys
* We generate an Admin password (needed for RDP logon) on the fly from user input when creating the VM
* Only RDP connections from a single trusted IP address are allowed
* Use **Fail2ban** to ban IPs that have multiple unsuccessful login attempts

NSG is a basic type of firewall, that is relatively dumb. 
It does not know about applications, it just filters network packets based on rules.
So we use it to block all incoming connections from the internet, except SSH and RDP.
To connect using SSH, a private key is needed that is only available on my local desktop system.
To connect using RDP, it only accepts connections from the IP address attached to my local desktop system via my ISP.
When someone tries to brute force the SSH connection, their IP is banned after a few unsuccessful login attempts.

Hopefully this is enough, and I did not make any mistake here :) 

(Apparently, Microsoft has created a product "Azure Bastion" for our use case, when we want to use RDP / remote desktop into a VM on Azure, but do not want to use a VPN or expose the VM using a public IP address.)

## SSH access

A common, secure way of connecting to a VM is through a "secure shell" aka SSH connection.
It is secure because all traffic is encrypted. We can either use passwords or work with "key pairs". We choose SSH keys because it is safer, since passwords can be guessed or brute-force discovered.

SSH works with so-called "key pairs", that consist of a public and private key. The private key is kept secret and is stored on our local system. The public key is passed to the VM when it is created. The VM uses this public key to encrypt all communication. To decrypt this communication, the private key is needed. Since nobody else has this key except we ourselves on our local system in a safe place, the connection is safeguarded.

We need to generate a public and private key for ourselves, and get it own the new VM.
We use the `--generate-ssh-keys` parameter to create them the first time. After that, since we already have a key pair, this parameter uses existing keys in `~/.ssh`.

Since SSH communication goes back and forth between our local system and the VM, we also need to encrypt the information we send to the VM. For that we need to use the **VM's public** key that it hands out to whoever wants to communicate with it.

```
ssh-keyscan -H $mypublicdns.westeurope.cloudapp.azure.com >> ~/.ssh/known_hosts
```

After all this, we can connect to the VM using SSH without the need to supply a password, the key-pairs in the background take care of the authentication process.

```
ssh azureuser@gsverhoeven.westeurope.cloudapp.azure.com
```
## Remote desktop access using RDP

Since we want to use the VM as a remote desktop, we need a connection that supports graphics.
Both RDP and VNC are popular protocols for remote desktop access. I went with RDP as it appears the faster of the two, and because RDP is natively supported in Windows. 

I did not explore tunneling RDP over SSH or VPN because it would reduce performance too much, and it requires too much configuration on the client side, which is often not possible with company restricted laptops. 

To be able to use RDP with Linux we need to install `xrdp`. To be able to login to `xrdp` requires setting a password for the user that logs in, introducing a security risk that we need to mitigate.

## Interactive password generation for RDP access

For remote desktop access with sufficient performance (no lags) we still need to set a password on the VM when we create it.
Since we want a fully scripted process of VM creation, I needed a secure way to generate and set a password during VM creation. In the end, I figured out a way to accomplish this using a shell script with an interactive prompt, that dynamically inserts the hashed password into the Cloud-init config file. This config file is then used to set the password on the VM upon creation, after which the copy of the config file containing the hashed password is deleted.

```
echo "generate cloud-config with encrypted password .."
read -sp 'Enter password for Cloud-config: ' SECRET
HASHEDPW=$(mkpasswd $SECRET --method=SHA-512 --rounds=4096)
cp $customDataScript $customDataScript.tmp
sed -i -e "/password:/ s@:.*@: $HASHEDPW@" $customDataScript.tmp
```

This way, I do not have to store a hashed password, not in the Github code repository, or on my local computer.
I have the password stored in my Keepass password manager in case I should forget it.

## Fail2ban for SSH

fail2ban will dynamically block brute force attacks on the remote system. It is pre-configured for the default ssh port 22/tcp. As I am writing this blog, the VM is up and running, and every few hours an IP address get banned.
It is configured to ban an IP after 5 login attempts. A ban lasts for 10 min, after which the ban is released again.
Apparantly this is for performance reasons, as we do not want to gather a very long list of IP address that needs to be scanned every time a new login attempt is made.

```
sudo apt install fail2ban
```

It is not enabled by default.
```
systemctl status fail2ban.service
```

```
sudo cp jail.conf jail.local
sudo systemctl enable fail2ban
sudo systemctl start fail2ban
```

N.b. it looks like fail2ban does not by default monitors failed xrdp login attempts.
https://stackoverflow.com/questions/75915624/xrdp-filter-setting-for-fail2ban

# Adding software to the Ubuntu base image

## A desktop enviroment

https://learn.microsoft.com/en-us/azure/virtual-machines/linux/use-remote-desktop?tabs=azure-cli

Most Linux VMs in Azure don't have a desktop environment installed by default. Linux VMs are commonly managed using SSH connections rather than a desktop environment, however there are several desktop environments that you can choose to install. Depending on your choice of desktop environment, it consumes up to 2 GB of disk space and take up to ten minutes to both install and configure all the required packages.

install xfce4 lightweight desktop.

```
sudo DEBIAN_FRONTEND=noninteractive apt-get -y install xfce4
sudo apt install xfce4-session
```

Now that we have a desktop environment installed, configure a remote desktop service to listen for incoming remote access connections. xrdp is an open source Remote Desktop Protocol (RDP) server that is available on most Linux distributions and works well with xfce. Install xrdp on your Ubuntu VM as follows:

```
sudo apt-get -y install xrdp
sudo systemctl enable xrdp
sudo adduser xrdp ssl-cert
echo xfce4-session >~/.xsession
sudo service xrdp restart
```

Access will be through RDP (Remote Desktop Protocol).  Ubuntu provides the `Remmina` software for this.

## A browser

We need to browse online documentation so let's install `firefox`.

```
sudo apt install firefox
```

## R programming language plus tidyverse

We also want R with the tidyverse packages.
follow instructions on CRAN to install r-base. 
```
sudo apt install --no-install-recommends software-properties-common dirmngr
wget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc
sudo add-apt-repository "deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/"
sudo apt install --no-install-recommends r-base
```

Now we have the latest R (4.3.1)!

Next step is installing the R packages we need.
Often R packages contain C code that needs to be compiled.
So we need a C++ compiler.

```
sudo apt install make
sudo apt install g++
```

Tidyverse needs a lot of extra deb packages. So we install those first.
```
sudo apt install libssl-dev libcurl4-openssl-dev unixodbc-dev libxml2-dev libmariadb-dev libfontconfig1-dev libharfbuzz-dev libfribidi-dev libfreetype6-dev libpng-dev libtiff5-dev libjpeg-dev
```

```
install.packages("tidyverse")
install.packages("gapminder")
remotes::install_github(standev/cmdstanr)
cmdstanr::install_stan()
```

Installing tidyverse took about 30 min on my VM as all the packages and dependencies had to be compiled from source.

```
install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
devtools::install_github("rmcelreath/rethinking")
```

## Posit Rstudio IDE

Next up: install Rstudio. We browse to the website of Rstudio (Now Posit) and download the latest Ubuntu .deb installer.
To automate this:

```
curl -s https://www.posit.co/links/check_for_update?version=1.0.0 | grep -oEi 'update-version=([0-9]+\.[0-9]+\.[0-9]+)' | awk -F= '{print $2}'
```

```
https://download1.rstudio.org/electron/jammy/amd64/rstudio-2023.09.1-494-amd64.deb
```

```
cd Downloads/
sudo apt -y install gdebi-core 
sudo gdebi rstudio-2023.09.0-463-amd64.deb 
```

## Stan statistical software

Then we want to be able to compile Stan models.
```
mkdir Github
cd Github
git clone https://github.com/stan-dev/cmdstan.git --recursive
cd cmdstan/

make build
make examples/bernoulli/bernoulli
examples/bernoulli/bernoulli sample data file=examples/bernoulli/bernoulli.data.json
```

# TODO Cloudinit script for Installing software on the VM

We can install software using cloud init. It needs a script or cloud config that will be run directly after provisioning the VM.
This is called "User data" b y most cloud providers, M$ calls it custom-data.
If we pass a shell script to Cloud-init it will just execute it on provisioning.

```
sudo apt-get update
sudo apt install inxi
```

https://help.ubuntu.com/community/CloudInit

https://learn.microsoft.com/en-us/azure/virtual-machines/linux/using-cloud-init


# Lessons learned

Need a fast dev cycle, so need to work with images, and break down image building in steps that save intermediate results.
Possibly using a makefile. And develop locally to avoid cloud cost.

stamparm/ipsum repo with bad IPs, that actively scan. abuseipdb.com

# Azure cloud cost

We have three main cost drivers: 

* public IP address (2 euro / day), 
* virtual machine (2.5 euro / day for a `Standard D2s v3`) , 
* SSD disk (2 euro / day)



