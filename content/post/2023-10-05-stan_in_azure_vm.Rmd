---
title: 'Rstudio & Stan on a shoestring in the cloud using Azure-CLI'
author: "Gertjan Verhoeven"
date: '2023-09-21'
summary: Setting up A Linux Stan development environment on Azure.
slug: azure-stan-linux
draft: no
categories:
- Linux
- Statistics
tags:
- R
- cmdstanr
baseurl: https://gsverhoeven.github.io
header:
  image: headers/bb_heatmap_banner.png
  preview: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Time to explore what the cloud is all about, in particular what is called **Infrastructure as code**.
Our goal is to write code (i.e. scripts) using open-source tools to automatically set up cloud infrastructure.

For this I chose a specific use case, which is **spinning up a data analysis development environment with R, Rstudio and Stan tools** installed and configured. 

This has two big advantages, **reproducibility** and **lower switching cost**: 

* Scripting the compute resources that made a data analysis possible is the next level in reproducibility. 
* Ideally, we want our scripts to be independent of a particular cloud provider. This would allow us to easily change from e.g. Azure to Amazon AWS if things stagnate or we can get a better deal elsewhere.

After weighing my options, I chose to write Linux shell scripts that use Azure-CLI to deploy Linux Ubuntu VMs that are configured using Cloud-init. While doing so I discovered that being able to test changes locally first before deploying to the cloud speeds up development significantly. 

To summarize and motivate the tech choices I made:

* I chose **Azure** since my employer recently moved to Azure and me learning it would be beneficial for work.
* I chose **Azure-CLI** to avoid the additional abstraction layer introduced by more generic tools like **Terraform/OpenTofu** or **Ansible**
* I chose **Linux Ubuntu OS** to keep cost down, as it is free and needs less resources than **Windows 10/11**
* I chose **Cloud-init** as it appears to be an emerging standard to configure Linux cloud images
* I chose the **QEMU emulator** to run VMs locally to speed up development

The blog uses Linux throughout, but as it uses Azure-CLI it should work for Windows as well.

# Azure cloud cost

We start with creating a free account on Azure. This comes with 200 Euro free credit to spent within a month.
We have three main cost drivers: public IP adress (2 euro), virtual machine (2.5 euro) , disk (2 euro), for a period of three weeks. I chose a cheap simple machine with 2 CPU and 8 GB RAM (Standard D2s v3).

# Setting up our local IaaS dev environment

As mentioned above, we use both Azure-CLI and QEMU for local development.
My local desktop system is Ubuntu 18.04 LTS.

## Azure CLI

First we need to install `azure-cli`:

```
#downloads the signing key from Microsoft
curl -sL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null 
## creates a file called microsoft.gpg in the folder where keys are stored

AZ_REPO=$(lsb_release -cs) ## outputs the codename for the linux distribution i.e. Ubuntu 18.04 = bionic
echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $AZ_REPO main" | sudo tee /etc/apt/sources.list.d/azure-cli.list 
## writes that URL to the package resource list
sudo apt-get update
sudo apt-get install azure-cli
```

First time we need to login to Azure:
```
# Log in interactively.
az login
```

Test if it works by creating and deleting a new resource group:

```
az group create --location westeurope --resource-group MyCoolRG

az group delete --resource-group MyCoolRG
```

## QEMU

Next we install **QEMU**. The documentation for Cloud-init contains a [section on how to work with QEMU](https://cloudinit.readthedocs.io/en/23.3.3/tutorial/qemu.html).

QEMU on Linux required KVM. QEMU threw an error 
https://16shuklarahul.medium.com/how-to-fix-kvm-permission-denied-error-on-ubuntu-18-04-16-04-14-04-f04a6e23c0cd

Install QEMU:
```
sudo apt install qemu-kvm
```
This installs QEMU 2.11 (2018) that plays well with Ubuntu 18.04.
```
qemu-system-x86_64 --version

QEMU emulator version 2.11.1(Debian 1:2.11+dfsg-1ubuntu7.41)
Copyright (c) 2003-2017 Fabrice Bellard and the QEMU Project developers
```

https://askubuntu.com/questions/213512/buffer-i-o-error-on-device-fd0-logical-block-0-error


testing with QEMU first for the cloud-init part.

Here is example code that download a Cloud-init enabled Ubuntu 22.04 image (`jammy`) that we use for local testing.
The initial disk size of the image is 2.2 GB, which is too small to install all the software we need to run Rstudio.
So we increase the image size to 30GB.

```
wget https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img
qemu-img info jammy-server-cloudimg-amd64.img 
# 2.2 GB
qemu-img resize jammy-server-cloudimg-amd64.img 30G

qemu-system-x86_64                                            \
    -net nic                                                    \
    -net user
    -machine accel=kvm:tcg                                      \ # use hardware acceleration
    -cpu host                                                   \ # emulate host processor
    -m 1024                                                      \ # use 1 GB RAM
    -nographic                                                  \ # graphic window disabled
    -hda jammy-server-cloudimg-amd64.img                        \ # Set a virtual hard drive and use the specified image file 
    -smbios type=1,serial=ds='nocloud;s=http://10.0.2.2:8000/'
```

```
ubuntu@jammy:~$ sudo lsblk -d | grep disk
fd0     2:0    1     4K  0 disk 
sda     8:0    0    30G  0 disk 
```

I ended up writing a script `do_qemu.sh` that starts a local VM using the cloud-config YAML file that is also used to configure the Azure VM.

# Azure cloud in a nutshell

There is a hierarchical structure.
Azure works with resources. Resources are contained within resource groups.
Resource groups exist within a subscription.
Finally, subscriptions exist within management groups.

![](azure_scope-levels.png)

## Subscription

First is the Subscription. This we choose when we login.

## Resource Group

Within this subscription, we create a *Resource Group*, `myRG2`. 

This needs a location, Since I am in West europe, let's choose westeurope.

```
# create shell variables
resourceGroup=myRG2
location=westeurope
az group create --name $resourceGroup --location $location
az group show --resource-group myRG2
```
https://learn.microsoft.com/en-us/cli/azure/azure-cli-vm-tutorial-2

### Quick vs complete creation of VM

https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/virtual-machines/linux/quick-create-cli.md

https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/virtual-machines/linux/create-cli-complete.md

To quickly create a virtual machine (VM) in Azure, you can use a single Azure CLI command that uses default values to create any required supporting resources. Resources such as a virtual network, public IP address, and network security group rules are automatically created. For more control of your environment in production use, you may create these resources ahead of time and then add your VMs to them. 

## Virtual Network

Next we create a Virtual Network: 

```
# create shell variables
vnetName=StanDEV-VNet1
subnetName=StanDEV-Subnet1
vnetAddressPrefix=10.0.0.0/16
subnetAddressPrefix=10.0.0.0/24

az network vnet create \
  --name $vnetName \
  --resource-group $resourceGroup \
  --address-prefixes $vnetAddressPrefix \
  --subnet-name $subnetName \
  --subnet-prefixes $subnetAddressPrefix
```


## Public IP address

Now let's create a public IP address with `az network public-ip create`. 
Public IP addresses come in two different flavours (or "SKU"s , stock keeping units), **Standard** which is better than **Basic**. We use **standard**, as its the default and its better.
This always results in a static IP address.


*Standard SKU: Secure by default model and be closed to inbound traffic when used as a frontend. Allow traffic with network security group is required (for example, on the NIC of a virtual machine with a Standard SKU public IP attached).*

```
publicIP=TEST-public-ip
mypublicdns=gsverhoeven

az network public-ip create \
    --resource-group $resourceGroup \
    --name $publicIP \
    --dns-name $mypublicdns
```

This public IP address enables you to connect to your VMs from the Internet. 

This results in a Fully qualified domaine name `fqdn` of `gsverhoeven.westeurope.cloudapp.azure.com`

```
nslookup  gsverhoeven.westeurope.cloudapp.azure.com
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	gsverhoeven.westeurope.cloudapp.azure.com
Address: 68.219.248.112
```

```
az network public-ip list -o table
```

```
Name            ResourceGroup    Location    Zones    Address        IdleTimeoutInMinutes    ProvisioningState
--------------  ---------------  ----------  -------  -------------  ----------------------  -------------------
TEST-public-ip  myRGtest         westeurope           104.46.41.142  4                       Succeeded

```

## Create network security group & Rules

To control the flow of traffic in and out of your VMs, apply a **network security group** to a virtual NIC or subnet. The following example uses `az network nsg create` to create a network security group named `myNetworkSecurityGroup`:

```
NetworkSecurityGroup=myNSG

az network nsg create \
    --resource-group $resourceGroup \
    --name $NetworkSecurityGroup
```

You define rules that allow or deny specific traffic. 

**To allow inbound connections on port 22 (to enable SSH access)**, create an inbound rule with `az network nsg rule create`. The following example creates a rule named `myNetworkSecurityGroupRuleSSH`:

```
az network nsg rule create \
    --resource-group myResourceGroup \
    --nsg-name myNetworkSecurityGroup \
    --name myNetworkSecurityGroupRuleSSH \
    --protocol tcp \
    --priority 1000 \
    --destination-port-range 22 \
    --access allow
```

To allow **Remote Desktop traffic** to reach your Linux VM, add another network security group rule.
The following example creates a rule named `myNetworkSecurityGroupRuleRDP`:

```
az network nsg rule create \
    --resource-group $resourceGroup \
    --nsg-name $NetworkSecurityGroup \
    --name myNetworkSecurityGroupRuleRDP \
    --description "Allow RDP at port 3389" \
    --direction Inbound \
    --protocol tcp \
    --priority 1001 \
    --destination-port-range 3389 \
    --access allow
```

Examine the network security group and rules with `az network nsg rule list`:

```
az network nsg rule list --resource-group myRG --nsg-name StanDEV-nsg --output table
```

## Create NIC

Virtual network interface cards (NICs) are programmatically available because you can apply rules to their use. 
In the following `az network nic create` command, you create a NIC named `myNic` and associate it with your network security group. The public IP address `myPublicIP` is also associated with the virtual NIC.

```
az network nic create \
    --resource-group $resourceGroup \
    --name $NICName \
    --vnet-name $vnetName \
    --subnet $subnetName \
    --public-ip-address $publicIP \
    --network-security-group $NetworkSecurityGroup
```

## Storage

When an Azure virtual machine is created, two disks are automatically attached to the virtual machine.

* Operating system disk - Operating system disks can be sized up to 2 TB, and hosts the VMs operating system. The OS disk is labeled `/dev/sda` by default. The disk caching configuration of the OS disk is optimized for OS performance. Because of this configuration, the OS disk should not be used for applications or data. 

(For applications and data, use data disks, which are detailed later in this tutorial.)

* Temporary disk - Temporary disks use a solid-state drive that is located on the same Azure host as the VM. Temp disks are highly performant and may be used for operations such as temporary data processing. However, if the VM is moved to a new host, any data stored on a temporary disk is removed. The size of the temporary disk is determined by the VM size. Temporary disks are labeled `/dev/sdb` and have a mountpoint of `/mnt`.

The Disk types are controlled by the `-storage-sku` option:

```
--storage-sku
```

The SKU of the storage account with which to persist VM. Use a singular sku that would be applied across all disks, or specify individual disks. Usage: [--storage-sku SKU | --storage-sku ID=SKU ID=SKU ID=SKU...], where each ID is "os" or a 0-indexed lun. Allowed values: Standard_LRS, Premium_LRS, StandardSSD_LRS, UltraSSD_LRS, Premium_ZRS, StandardSSD_ZRS, PremiumV2_LRS.

https://learn.microsoft.com/en-us/azure/virtual-machines/disks-types

For now we only want OS disk, and we want it  fast so SSD. But we choose `StandardSSD_LRS` for lower cost.
We get 30GB OSdisk and 7GB tmp disk.

## VM Size choice

`Standard` is recommended tier.

```
D – General purpose compute
2 – VM Size
s – Premium Storage capable
v3 – version
```

PM Did not choose size. want standardds1_v2

## VM Image choice

There are many choices here in the Azure Marketplace.
Canonical offers various Ubuntu images here.

Canonical is the publisher of official Ubuntu images on Microsoft Azure. Users can find the latest Ubuntu images in the Azure Marketplace when using the web interface. For a programmatic interface, users can use Microsoft’s Azure CLI 32. All images published by Canonical are discoverable using the following command:

```
az vm image list-skus \
--publisher Canonical \
--offer Ubuntu \
--location westeurope \
-o table
```

I chose Ubuntu Server 20.04 LTS, because Linux, and to keep cost low (PM check if this is actually cheaper than WinOS).

## Cloudinit script for Installing software on the VM

We can install software using cloud init. It needs a script or cloud config that will be run directly after provisioning the VM.
This is called "User data" b y most cloud providers, M$ calls it custom-data.
If we pass a shell script to Cloud-init it will just execute it on provisioning.

https://help.ubuntu.com/community/CloudInit

https://learn.microsoft.com/en-us/azure/virtual-machines/linux/using-cloud-init

```
cloud-init devel make-mime -a config.yaml:cloud-config -a script.sh:x-shellscript > userdata
```

```
mkpasswd test --method=SHA-512 --rounds=4096
```

## How to use Remote Desktop with Linux?

https://learn.microsoft.com/en-us/azure/virtual-machines/linux/use-remote-desktop?tabs=azure-cli

Most Linux VMs in Azure don't have a desktop environment installed by default. Linux VMs are commonly managed using SSH connections rather than a desktop environment, however there are several desktop environments that you can choose to install. Depending on your choice of desktop environment, it consumes up to 2 GB of disk space and take up to ten minutes to both install and configure all the required packages.

```
sudo apt-get update
sudo apt install inxi
```

install xfce4 lightweight desktop.

```
sudo DEBIAN_FRONTEND=noninteractive apt-get -y install xfce4
sudo apt install xfce4-session
```

Now that you have a desktop environment installed, configure a remote desktop service to listen for incoming remote access connections. xrdp is an open source Remote Desktop Protocol (RDP) server that is available on most Linux distributions and works well with xfce. Install xrdp on your Ubuntu VM as follows:

```
sudo apt-get -y install xrdp
sudo systemctl enable xrdp
sudo adduser xrdp ssl-cert
echo xfce4-session >~/.xsession
sudo service xrdp restart
```

Access will be through RDP (Remote Desktop Protocol).  Ubuntu provides the `Remmina` software for this.

### Setting up a Stan development environment on Ubuntu 20.04

Now let's install the software we need.
We need to browse GitHub so lets install firefox.

```
sudo apt install firefox
```

Then we want to be able to compile Stan models.
```
mkdir Github
cd Github
git clone https://github.com/stan-dev/cmdstan.git --recursive
cd cmdstan/
sudo apt install make
sudo apt install g++
make build
make examples/bernoulli/bernoulli
examples/bernoulli/bernoulli sample data file=examples/bernoulli/bernoulli.data.json
```

We also want R.
follow instructions on CRAN to install r-base. 
```
sudo apt install --no-install-recommends software-properties-common dirmngr
wget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc
sudo add-apt-repository "deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/"
sudo apt install --no-install-recommends r-base
```

Now we have the latest R (4.3.1)!

Next up: install Rstudio. We browse to the website of Rstudio (Now Posit) and download the latest Ubuntu .deb installer.
To automate this:
```
curl -s https://www.posit.co/links/check_for_update?version=1.0.0 | grep -oEi 'update-version=([0-9]+\.[0-9]+\.[0-9]+)' | awk -F= '{print $2}'
```

```{r}
https://download1.rstudio.org/electron/jammy/amd64/rstudio-2023.09.1-494-amd64.deb
```

```
cd Downloads/
sudo apt -y install gdebi-core 
sudo gdebi rstudio-2023.09.0-463-amd64.deb 
```

Final step is installing the R packages we need.

Tidyverse needs a lot of extra deb packages. So we install those first.
```
sudo apt install libssl-dev libcurl4-openssl-dev unixodbc-dev libxml2-dev libmariadb-dev libfontconfig1-dev libharfbuzz-dev libfribidi-dev libfreetype6-dev libpng-dev libtiff5-dev libjpeg-dev
```

Then we fire up Rstudio. on the R command line we do:
using Rscript

```
Rscript -e 'print("hi there")'
```

```
install.packages("tidyverse")
install.packages("gapminder")
remotes::install_github(standev/cmdstanr)
cmdstanr::install_stan()
```

Installing tidyverse took about 30 min on my VM as all the packages and dependencies had to be compiled from source.

```
install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
devtools::install_github("rmcelreath/rethinking")
```

## Create the VM



Create the VM by bringing all the resources and information together with the `az vm create` command. 
The following example creates a VM:

**When specifying an existing NIC, do not specify NSG, public IP, ASGs, VNet or subnet.**



```
az vm create \
  --resource-group $resourceGroup \
  --name $vmName \
  --nics $NICName \
  --image $vmImage \
  --storage-sku $storagetype \
  --admin-username $AdminUsername \
  --generate-ssh-keys
```

# Security of a VM

For a public VM facing the internet, we need some security measures in place.
NSG is a basic type of firewall, that is relatively dumb. It does not know about applications, it just filters network packets based on rules.

## Creating a passwd 

we can generate a cloud config on the fly.
```
VM_NAME="ubuntu-20-cloud-image"
USERNAME="programster"
PASSWORD="thisok"
echo "#cloud-config
system_info:
  default_user:
    name: $USERNAME
    home: /home/$USERNAME

password: $PASSWORD
chpasswd: { expire: False }
hostname: $VM_NAME

# configure sshd to allow users logging in using password 
# rather than just keys
ssh_pwauth: True
" | sudo tee user-data
```

## RDP
We need to set a password to log on using RDP.

*If you only use SSH key authentication and don't have a local account password set, specify a password before you use xrdp to log in to your VM*. xrdp can't accept SSH keys for authentication. The following example specifies a password for the user account azureuser:

```
sudo passwd azureuser
```

Specifying a password does not update your SSHD configuration to permit password logins if it currently does not. 
For security reasons we should limit pwd retries and limit IP range to connect from.

## SSH

We need to generate a public and private key for ourselves, and get it own the new VM.

Specify an SSH key to use for authentication. If you do not have an SSH public key pair, you can create them or use the --generate-ssh-keys parameter to create them for you. If you already have a key pair, this parameter uses existing keys in ~/.ssh.


```
ssh azureuser@gsverhoeven.westeurope.cloudapp.azure.com
```

We start with ssh-ing into the VM. 

```
mv StanDEV_key.pem .ssh/
chmod 600 .ssh/StanDEV_key.pem
ssh -i ~/.ssh/StanDEV_key.pem azureuser@68.219.248.112
mynewip.northeurope.cloudapp.azure.com
```


ssh-keygen -f "/home/gertjan/.ssh/known_hosts" -R "gsverhoeven.westeurope.cloudapp.azure.com"

https://superuser.com/questions/1112092/hacking-attempts-to-linux-vm-in-azure

## Fail2ban

```
sudo apt install fail2ban
```

fail2ban will dynamically block brute force attacks on the remote system. It is pre-configured for the default ssh port 22/tcp. If the server is internet facing, you probably want to have the router perform port translation so your log files don't get filled with denied attempts. If you don't, expect 100,000 attempts every day.


## Starting, stopping and deallocating a VM

```
az vm start --resource-group myRG --name StanDEV
az vm stop --resource-group myRG --name StanDEV
About to power off the specified VM...
It will continue to be billed. To deallocate a VM, run: az vm deallocate
az vm deallocate --resource-group myRG --name StanDEV
```


# cloning a private repo from Github

Use GCM

```
git config --global credential.credentialStore gpg
sudo apt-get install pass
pass init gertjan.verhoeven@gmail.com
wget https://github.com/git-ecosystem/git-credential-manager/releases/download/v2.3.2/gcm-linux_amd64.2.3.2.deb
sudo dpkg -i gcm-linux_amd64.2.3.2.deb
git-credential-manager configure
git clone github.com/gsverhoeven/statistical_rethinking
```
First time I had tro use a github access token to sign into Github
second time I had to type the GPG passwd and marked store in pwd manager.
Third time it worked!!!!

better send this over secure rdp



# Clean up resources

```
az group delete --name $RESOURCE_GROUP_NAME --no-wait --yes --verbose
```

How can we get overview of all resources?

```
az resource list --output table
```

# Now windows 10

https://smsagent.blog/2020/02/03/the-cost-of-running-a-personal-windows-10-vm-in-azure/

```
az vm image list --all -f "Windows-10" -p "MicrosoftWindowsDesktop" -o table
```

# Lessons learned

Need a fast dev cycle, so need to work with images, and break down image building in steps that save intermediate results.
Possibly using a makefile. And develop locally to avoid cloud cost.
