---
title: 'Rstudio & Stan on a shoestring in the cloud using Azure VMs'
author: "Gertjan Verhoeven"
date: '2023-09-21'
summary: Setting up A Linux Stan development environment on Azure.
slug: azure-stan-linux
draft: no
categories:
- Linux
- Statistics
tags:
- R
- cmdstanr
baseurl: https://gsverhoeven.github.io
header:
  image: headers/bb_heatmap_banner.png
  preview: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Time to explore what the cloud is all about.

Our goal is to use an open-source script language to automatically set up cloud infrastructure.
The grand idea here is that scripting the compute resources that made an analysis possible is the next level in reproducibility.
In addition, we hope to avoid cloud vendor lock-in if we automate the cloud infrastructure using open source tooling.
The reasoning is, since both the hardware and software are just a bunch of open source scripts, we can pick up our bags and leave as soon as things stagnate or we can get a better deal elsewhere.

It would be nice to we create a VM that we can use for Stan Modelling when we need it, and tear it down when we no longer need it.
The blog uses Linux throughout, but as it uses Azure-CLI it should work for Windows as well.

# Azure cloud

We start with creating a free account on Azure. This comes with 200 Euro free credit to spent within a month.
By doing all configuration using **az**, we build a script that automates the creation of our infrastructure.
hence, **Infrastructure as code**.

## Azure cost

We have three main cost drivers: public IP adress (2 euro), virtual machine (2.5 euro) , disk (2 euro), for a period of three weeks. I chose a cheap simple machine with 2 CPU and 8 GB RAM (Standard D2s v3).

# Automate with Azure-CLI

First we need to install `azure-cli` on our desktop system (Ubuntu 18.04 LTS):

```
#downloads the signing key from Microsoft
curl -sL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null 
## creates a file called microsoft.gpg in the folder where keys are stored

AZ_REPO=$(lsb_release -cs) ## outputs the codename for the linux distribution i.e. Ubuntu 18.04 = bionic
echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $AZ_REPO main" | sudo tee /etc/apt/sources.list.d/azure-cli.list 
## writes that URL to the package resource list
sudo apt-get update
sudo apt-get install azure-cli
az login
```

Test if it works by listing the contents of one of my resource groups:

```
az resource list --resource-group myRG
```

## Azure cloud management levels

There is a hierarchical structure.
Azure works with resources. Resources are contained within resource groups.
Resource groups exist within a subscription.
Finally, subscriptions exist within management groups.

![](azure_scope-levels.png)

## Subscription

First is the Subscription. This we choose when we login.

```
az login
```

## Resource Group

Within this subscription, we create a *Resource Group*, `myRG2`. 

This needs a location, Since I am in West europe, let's choose westeurope.

```
# create shell variables
resourceGroup=myRG2
location=westeurope
az group create --name $resourceGroup --location $location
az group show --resource-group myRG2
```
https://learn.microsoft.com/en-us/cli/azure/azure-cli-vm-tutorial-2

### Quick vs complete creation of VM

https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/virtual-machines/linux/quick-create-cli.md

https://github.com/MicrosoftDocs/azure-docs/blob/main/articles/virtual-machines/linux/create-cli-complete.md

To quickly create a virtual machine (VM) in Azure, you can use a single Azure CLI command that uses default values to create any required supporting resources. Resources such as a virtual network, public IP address, and network security group rules are automatically created. For more control of your environment in production use, you may create these resources ahead of time and then add your VMs to them. 

## Virtual Network

Next we create a Virtual Network: 

```
# create shell variables
vnetName=StanDEV-VNet1
subnetName=StanDEV-Subnet1
vnetAddressPrefix=10.0.0.0/16
subnetAddressPrefix=10.0.0.0/24

az network vnet create \
  --name $vnetName \
  --resource-group $resourceGroup \
  --address-prefixes $vnetAddressPrefix \
  --subnet-name $subnetName \
  --subnet-prefixes $subnetAddressPrefix
```


## Public IP address

Now let's create a public IP address with `az network public-ip create`. 
Public IP addresses come in two different flavours (or "SKU"s , stock keeping units), **Standard** which is better than **Basic**. We use **standard**, as its the default and its better.
This always results in a static IP address.


*Standard SKU: Secure by default model and be closed to inbound traffic when used as a frontend. Allow traffic with network security group is required (for example, on the NIC of a virtual machine with a Standard SKU public IP attached).*

```
publicIP=TEST-public-ip
mypublicdns=gsverhoeven

az network public-ip create \
    --resource-group $resourceGroup \
    --name $publicIP \
    --dns-name $mypublicdns
```

This public IP address enables you to connect to your VMs from the Internet. 

This results in a `fqdn` of `gsverhoeven.westeurope.cloudapp.azure.com`

```
nslookup  gsverhoeven.westeurope.cloudapp.azure.com
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	gsverhoeven.westeurope.cloudapp.azure.com
Address: 68.219.248.112
```

```
az network public-ip list -o table
```

```
Name            ResourceGroup    Location    Zones    Address        IdleTimeoutInMinutes    ProvisioningState
--------------  ---------------  ----------  -------  -------------  ----------------------  -------------------
TEST-public-ip  myRGtest         westeurope           104.46.41.142  4                       Succeeded

```

## Create network security group & Rules

To control the flow of traffic in and out of your VMs, apply a **network security group** to a virtual NIC or subnet. The following example uses `az network nsg create` to create a network security group named `myNetworkSecurityGroup`:

```
NetworkSecurityGroup=myNSG

az network nsg create \
    --resource-group $resourceGroup \
    --name $NetworkSecurityGroup
```

You define rules that allow or deny specific traffic. 

**To allow inbound connections on port 22 (to enable SSH access)**, create an inbound rule with `az network nsg rule create`. The following example creates a rule named `myNetworkSecurityGroupRuleSSH`:

```
az network nsg rule create \
    --resource-group myResourceGroup \
    --nsg-name myNetworkSecurityGroup \
    --name myNetworkSecurityGroupRuleSSH \
    --protocol tcp \
    --priority 1000 \
    --destination-port-range 22 \
    --access allow
```

To allow **Remote Desktop traffic** to reach your Linux VM, add another network security group rule.
The following example creates a rule named `myNetworkSecurityGroupRuleRDP`:

```
az network nsg rule create \
    --resource-group $resourceGroup \
    --nsg-name $NetworkSecurityGroup \
    --name myNetworkSecurityGroupRuleRDP \
    --description "Allow RDP at port 3389" \
    --direction Inbound \
    --protocol tcp \
    --priority 1001 \
    --destination-port-range 3389 \
    --access allow
```

Examine the network security group and rules with `az network nsg rule list`:

```
az network nsg rule list --resource-group myRG --nsg-name StanDEV-nsg --output table
```

## Create NIC

Virtual network interface cards (NICs) are programmatically available because you can apply rules to their use. 
In the following `az network nic create` command, you create a NIC named `myNic` and associate it with your network security group. The public IP address `myPublicIP` is also associated with the virtual NIC.

```
az network nic create \
    --resource-group $resourceGroup \
    --name $NICName \
    --vnet-name $vnetName \
    --subnet $subnetName \
    --public-ip-address $publicIP \
    --network-security-group $NetworkSecurityGroup
```

## Storage

When an Azure virtual machine is created, two disks are automatically attached to the virtual machine.

* Operating system disk - Operating system disks can be sized up to 2 TB, and hosts the VMs operating system. The OS disk is labeled `/dev/sda` by default. The disk caching configuration of the OS disk is optimized for OS performance. Because of this configuration, the OS disk should not be used for applications or data. 

(For applications and data, use data disks, which are detailed later in this tutorial.)

* Temporary disk - Temporary disks use a solid-state drive that is located on the same Azure host as the VM. Temp disks are highly performant and may be used for operations such as temporary data processing. However, if the VM is moved to a new host, any data stored on a temporary disk is removed. The size of the temporary disk is determined by the VM size. Temporary disks are labeled `/dev/sdb` and have a mountpoint of `/mnt`.

The Disk types are controlled by the `-storage-sku` option:

```
--storage-sku
```

The SKU of the storage account with which to persist VM. Use a singular sku that would be applied across all disks, or specify individual disks. Usage: [--storage-sku SKU | --storage-sku ID=SKU ID=SKU ID=SKU...], where each ID is "os" or a 0-indexed lun. Allowed values: Standard_LRS, Premium_LRS, StandardSSD_LRS, UltraSSD_LRS, Premium_ZRS, StandardSSD_ZRS, PremiumV2_LRS.

https://learn.microsoft.com/en-us/azure/virtual-machines/disks-types

For now we only want OS disk, and we want it  fast so SSD. But we choose `StandardSSD_LRS` for lower cost.
We get 30GB OSdisk and 7GB tmp disk.

## Create VM

Within the Resource Group, we create a *Virtual Machine*. 

### Size choice

Standard is recommended tier
D – General purpose compute
2 – VM Size
s – Premium Storage capable
v3 – version

PM Did not choose size. want standardds1_v2

### Image choice

There are many choices here in the Azure Marketplace.
Canonical offers various Ubuntu images here.

Canonical is the publisher of official Ubuntu images on Microsoft Azure. Users can find the latest Ubuntu images in the Azure Marketplace when using the web interface. For a programmatic interface, users can use Microsoft’s Azure CLI 32. All images published by Canonical are discoverable using the following command:

```
az vm image list-skus \
--publisher Canonical \
--offer Ubuntu \
--location westeurope \
-o table
```

I chose Ubuntu Server 20.04 LTS, because Linux, and to keep cost low (PM check if this is actually cheaper than WinOS).

Create the VM by bringing all the resources and information together with the `az vm create` command. 
The following example creates a VM:

**When specifying an existing NIC, do not specify NSG, public IP, ASGs, VNet or subnet.**

```
az vm create \
  --resource-group $resourceGroup \
  --name $vmName \
  --nics $NICName \
  --image $vmImage \
  --storage-sku $storagetype \
  --admin-username $AdminUsername \
  --generate-ssh-keys
```

## SSH

Specify an SSH key to use for authentication. If you do not have an SSH public key pair, you can create them or use the --generate-ssh-keys parameter to create them for you. If you already have a key pair, this parameter uses existing keys in ~/.ssh.


```
ssh azureuser@gsverhoeven.westeurope.cloudapp.azure.com
```

We start with ssh-ing into the VM. 

```
mv StanDEV_key.pem .ssh/
chmod 600 .ssh/StanDEV_key.pem
ssh -i ~/.ssh/StanDEV_key.pem azureuser@68.219.248.112
```


ssh-keygen -f "/home/gertjan/.ssh/known_hosts" -R "gsverhoeven.westeurope.cloudapp.azure.com"

## Starting, stopping and deallocating a VM

```
az vm start --resource-group myRG --name StanDEV
az vm stop --resource-group myRG --name StanDEV
About to power off the specified VM...
It will continue to be billed. To deallocate a VM, run: az vm deallocate
az vm deallocate --resource-group myRG --name StanDEV
```

# Clean up resources

```
az group delete --name $RESOURCE_GROUP_NAME --no-wait --yes --verbose
```

How can we get overview of all resources?

```
az resource list --output table
```

```
Name                                                                       ResourceGroup                   Location     Type                                          Status
-------------------------------------------------------------------------  ------------------------------  -----------  --------------------------------------------  --------
csb100320010bd52506                                                        cloud-shell-storage-westeurope  westeurope   Microsoft.Storage/storageAccounts
Automate-a61954d3-c5e4-486b-a6b4-5adce7816139-NE                           DefaultResourceGroup-NEU        northeurope  Microsoft.Automation/automationAccounts
DefaultWorkspace-a61954d3-c5e4-486b-a6b4-5adce7816139-NEU                  DefaultResourceGroup-NEU        northeurope  Microsoft.OperationalInsights/workspaces
ChangeTracking(DefaultWorkspace-a61954d3-c5e4-486b-a6b4-5adce7816139-NEU)  DefaultResourceGroup-NEU        northeurope  Microsoft.OperationsManagement/solutions
Updates(DefaultWorkspace-a61954d3-c5e4-486b-a6b4-5adce7816139-NEU)         DefaultResourceGroup-NEU        northeurope  Microsoft.OperationsManagement/solutions
StanDEV_OsDisk_1_7bafa5019829421bab4f1a90bb337169                          MYRG                            northeurope  Microsoft.Compute/disks
StanDEV_key                                                                myRG                            northeurope  Microsoft.Compute/sshPublicKeys
StanDEV                                                                    myRG                            northeurope  Microsoft.Compute/virtualMachines
standev363_z1                                                              myRG                            northeurope  Microsoft.Network/networkInterfaces
StanDEV-nsg                                                                myRG                            northeurope  Microsoft.Network/networkSecurityGroups
StanDEV-vnet                                                               myRG                            northeurope  Microsoft.Network/virtualNetworks
NetworkWatcher_northeurope                                                 NetworkWatcherRG                northeurope  Microsoft.Network/networkWatchers
NetworkWatcher_westeurope                                                  NetworkWatcherRG                westeurope   Microsoft.Network/networkWatchers
```

## run-command to remotely install software

We can use `run-command` to remotely install software.
Using below command we can execute a specific run command on a vm.

```
az vm run-command invoke \
   --resource-group $resourceGroup \
   --name $vmName \
   --command-id RunShellScript \
   --scripts "sudo apt-get update && sudo apt install net-tools"
```

# Cloudinit Installing software on the VM

We can install software using cloud init.
This is called "User data", M$ calls it custom-data.
If we pass a shell script to Cloud-init it will just execute it on provisioning.

https://help.ubuntu.com/community/CloudInit

https://stackoverflow.com/questions/38333917/running-init-script-on-a-linux-instance-at-launch-on-azure
https://learn.microsoft.com/en-us/azure/virtual-machines/linux/using-cloud-init

```
az vm create \
  --resource-group myResourceGroup \
  --name centos74 \
  --image OpenLogic:CentOS-CI:7-CI:latest \
  --custom-data cloud-init.txt \
  --generate-ssh-keys 
```

https://learn.microsoft.com/en-us/azure/virtual-machines/linux/tutorial-automate-vm-deployment

## How to use Remote Desktop with Linux?

https://learn.microsoft.com/en-us/azure/virtual-machines/linux/use-remote-desktop?tabs=azure-cli

Most Linux VMs in Azure don't have a desktop environment installed by default. Linux VMs are commonly managed using SSH connections rather than a desktop environment, however there are several desktop environments that you can choose to install. Depending on your choice of desktop environment, it consumes up to 2 GB of disk space and take up to ten minutes to both install and configure all the required packages.



```
sudo apt-get update
sudo apt install inxi
```

install xfce4 lightweight desktop.

```
sudo DEBIAN_FRONTEND=noninteractive apt-get -y install xfce4
sudo apt install xfce4-session
```

Now that you have a desktop environment installed, configure a remote desktop service to listen for incoming remote access connections. xrdp is an open source Remote Desktop Protocol (RDP) server that is available on most Linux distributions and works well with xfce. Install xrdp on your Ubuntu VM as follows:

```
sudo apt-get -y install xrdp
sudo systemctl enable xrdp
sudo adduser xrdp ssl-cert
echo xfce4-session >~/.xsession
sudo service xrdp restart
```

Access will be through RDP (Remote Desktop Protocol).  Ubuntu provides the `Remmina` software for this.
We need to set a password to log on using RDP.

*If you only use SSH key authentication and don't have a local account password set, specify a password before you use xrdp to log in to your VM*. xrdp can't accept SSH keys for authentication. The following example specifies a password for the user account azureuser:

```
sudo passwd azureuser
```

Specifying a password does not update your SSHD configuration to permit password logins if it currently does not. 


## Setting up a Stan development environment on Ubuntu 20.04

Now let's install the software we need.
We need to browse GitHub so lets install firefox.

```
sudo apt install firefox
```

Then we want to be able to compile Stan models.
```
mkdir Github
cd Github
git clone https://github.com/stan-dev/cmdstan.git --recursive
cd cmdstan/
sudo apt install make
sudo apt install g++
make build
make examples/bernoulli/bernoulli
examples/bernoulli/bernoulli sample data file=examples/bernoulli/bernoulli.data.json
```

We also want R.
follow instructions on CRAN to install r-base. 
```
sudo apt install --no-install-recommends software-properties-common dirmngr
wget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc
sudo add-apt-repository "deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/"
sudo apt install --no-install-recommends r-base
```

Now we have the latest R (4.3.1)!

Next up: install Rstudio. We browse to the website of Rstudio (Now Posit) and download the latest Ubuntu .deb installer.
```
cd Downloads/
sudo apt -y install gdebi-core 
sudo gdebi rstudio-2023.09.0-463-amd64.deb 
```

Final step is installing the R packages we need.

Tidyverse needs a lot of extra deb packages. So we install those first.
```
sudo apt install libssl-dev libcurl4-openssl-dev unixodbc-dev libxml2-dev libmariadb-dev libfontconfig1-dev libharfbuzz-dev libfribidi-dev libfreetype6-dev libpng-dev libtiff5-dev libjpeg-dev
```

Then we fire up Rstudio. on the R command line we do:

```
install.packages("tidyverse")
install.packages("gapminder")
remotes::install_github(standev/cmdstanr)
cmdstanr::install_stan()
```

Installing tidyverse took about 30 min on my VM as all the packages and dependencies had to be compiled from source.

```
install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
devtools::install_github("rmcelreath/rethinking")
```



# Now without Azure CLI?

This blog used Azure CLI. However, this is vendor specific.
Next step would be to accomplish the same thing with vendor independent tooling such as Terraform /openTofu or Ansible.

## Export Azure Resource Manager  Template (ARM) for reuse

```
az group export --name myRG > myResourceGroup.json
```

## Hashicorp Terraform

One of the advantages of Terraform is that it creates a single source of truth (that HCL file) that can be deployed over and over again without having to understand how it gets to the end-state. Another advantage of the Terraform approach is that it is just as easy to tear down (de-provision) your cloud resources. This allows developers to quickly spin up resources, test something, then tear them down.

https://cloudinfrastructureservices.co.uk/how-to-install-terraform-on-ubuntu-server-20-04/

```
sudo apt-add-repository "deb [arch=$(dpkg --print-architecture)] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
sudo apt-get install terraform -y
terraform -v
```

## Ansible

Ansible is an open-source tool that automates cloud provisioning, configuration management, and application deployments. Using Ansible you can provision virtual machines, containers, network, and complete cloud infrastructures. In addition, Ansible allows you to automate the deployment and configuration of resources in your environment.

Ansible, by design, takes an imperative approach to automation.  You simply have a task list that iterates through each resource.  You would tell it to provision this VPC, this subnet, then this VM.  The advantage of this approach is it is very simple to understand, there is no hidden magic, which helps it become easy to troubleshoot.  The disadvantage is usually it is more cumbersome to do teardowns and de-provision without knowing the correct order.  I have to delete the instance, then the security group, and so on and so forth.

Ansible includes a suite of Ansible modules that can be executed directly on remote hosts or via playbooks. Users can also create their own modules. Modules can be used to control system resources - such as services, packages, or files - or execute system commands.

For interacting with Azure services, Ansible includes a suite of Ansible cloud modules that provides the tools to easily create and orchestrate your infrastructure on Azure.
