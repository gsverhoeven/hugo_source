---
title: 'Classifying Blood Bowl teams using clustered heatmaps'
author: "Gertjan Verhoeven"
date: '2022-11-01'
bibliography: heatmap_post/2022_clusterheatmap_blog_post.json
summary: This blog post compares two unsupervised learning methods to learn which Blood Bowl teams are similar. Similarity is quantified by looking atvarious match related metrics from such as scoring, injuries, passes and blocks.
slug: blood-bowl-cluster-analysis
draft: yes
categories:
- Blood Bowl
- Machine Learning
- Clustering
- Unsupervised learning
tags:
- t-sne
- pca
baseurl: https://gsverhoeven.github.io
header:
  image: headers/wilhelm-gunkel-di8ognBauG0-unsplash.png
  preview: no
editor_options: 
  chunk_output_type: inline
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load packages
library(tidyverse)
library(ggfortify)
library(ggrepel)
```


# Introduction

"If you graph the numbers of any natural system, patterns emerge" (slightly paraphrased) is one of my favorite movie quotes (from Darren Aronofsky's cult movie $\pi$ ("pi")).In this plot we'll graph the numbers from the Blood Bowl Fantasy football game, and see what patterns emerge. Blood Bowl is a board game that can be summarized as "fantasy-chess-with-dice" , but this would hardly do the game justice. For example, in chess both players play with the same pieces, but in Blood Bowl, almost 30 different teams (e.g. orcs, elves, etc) are available to choose from, each team with different skills that require different playing styles. In addition, Blood Bowl coaches must assemble and paint their playing pieces themselves, making it a creative hobby as well.

Using data analysis, we can cluster teams that have similar (average) match performance statistics and graph the data using heatmaps. Heatmaps are a graphical representation of the data, with for example darker colors representing higher numbers. This allows patterns to emerge visually, and deviations on the patterns are also easy to spot. Note that a hundred years ago, people already "shaded matrices" but did not call it a heatmap [@wilkinson_friendly09].

Teams with similar stats can still be different on some aspect not captured in the data, but let's just have a look at what we get! 

First we need data. Blood Bowl can also be played online at FUMBBL.com, from which I scraped the match data (detailed in a [previous blog post](https://gsverhoeven.github.io/post/blood-bowl-fumbbl-dataset/)). I made the match data (currently from August 2020 up to June 2022) publicly available in a [Github repository](https://github.com/gsverhoeven/fumbbl_datasets).

# Team play style categories

Bonehead podcast has top 5 dash and included underworld and lizardmen !!!

The most common way to classify the 25-30 different Blood Bowl teams is to distinguish four categories:

* Bash (Orcs, Dwarves, Chaos Chosen, Chaos Dwarves, Khemri (Tomb Kings), Nurgle)
* Agile (or Dash) ( Wood Elfs, High Elfs, Elven Union, Dark Elfs and Skaven)
* Hybrid (Humans, Amazons, Shambling Undead, Necromantic Horror and several more)
* Stunty (Goblins, Snotlings, Halflings, Ogres)

The first three categories are underpinned by the balance between primary skill access to **Agility** (Ball handling) and **Strength** ("bashing" of the opponent). Agile teams tend to have high mobility as well.

I wouldn't class undead as a bashy team. 4 players with ST access (Wights, Mummys) and 4 with AG access (4 Ghouls) makes them a hybrid team.
https://bbtactics.com/forum/threads/bashy-race-choice-for-league-play.4961/#post-127457

Other than Orcs, the other true "bash" teams are Dwarves, Chaos, Chaos Dwarves, Nurgle and perhaps Khemri
https://bbtactics.com/forum/threads/bashy-race-choice-for-league-play.4961/#post-127884

https://www.reddit.com/r/bloodbowl/comments/64o8hw/bashy_and_nonbashy_teams/

From dode on the Steam Community:

```
Depends on how you define an agility team, and how you measure how agile a bash team is.

For the first part, OCC tends to use:
Agi: High, Dark, Wood and Pro Elves, and Skaven
Hybrid: Zon, Human, Necro, Undead, Lizard, Norse
Bash: Orc, Dorf, Chaos Dorf, Chaos, Khemri, Nurgle
Non-T1: Vamps, Pact, Underworld, Ogre, Goblin, Fling, (Brets/Slann/Khorne - all Hybrid if you want the as T1 teams)

The distinction between Agi/Hybrid/Bash is largely based on skill access: does the team normally (i.e. on rosters regularly taken) have 4 A access or 4 S access players? If it doesn't have 4 A access then it's bash; if it doesn't have 4 S access then it's Agi; otherwise it's hybrid.
```

From dode on reddit:

```
OCC (Orca Cola Championship) uses the following system:

Bash: Orcs, Dwarves, Chaos, Chaos Dwarves, Khemri, Nurgle

Agility: Wood, High, Pro, Dark and Skaven

Hybrid: Amazon, Human, Norse, Necro, Undead, Lizard

Non-T1: Pact, Underworld, Slann, (Brets, Khorne, Simyin), Vamps

Stunty: Goblins, Halflings, Ogres

The bottom two are clearly performance-based, but there is an actual method behind the differentiation between Bash, Agi and Hybrid teams. If a team has 4+ S access players but fewer than 4 A access players it is Bash; if it has 4+ A access players but fewer than 4 S access players it is Agi; if it has 4 or more of each it is Hybrid.

This might look like Orcs should be hybrid, but they are so rarely played with more than one goblin (and very often with no goblins) so they go in the Bash category.

Brets, Khorne and Simyin are in brackets because their performance isn't as clearly defined. Khorne are intended as a T1.5 team and perform as such, and I believe Brets and Simyin are too. Khorne and Brets would be Hybrid teams and Simyin would be Bash if you wanted them to be categorised as the above are, though.
```

Teams that have **at least four players with strength access** but no or very little access to Agility skills are classified as Bash teams.
(source)

Teams that have **at least four players with agility access** but no or very little access to Strength skills are classified as Agile teams.
(source Dode)

Then there is Stunty.  ("weak", "difficult to play", "a lot of stunty (very small) players", "big guys with negatrait")

# Read and prep the data

We start with reading in the scraped FUMBBL match data, see my previous blog posts for details.

The dataset already contains a categorization into race types.
We need to fix this a bit.

```{r}
df_mbt <- read.csv(file = "../../../fumbbl_datasets/datasets/current/df_mbt.csv")

race_types <- unique(df_mbt %>% 
                       select(race_name, race_type) %>%
                       filter(race_type != "") %>%
                       arrange(race_type))


# Fix team classification
df_mbt <- df_mbt %>%
  mutate(race_type = if_else(race_name == "Shambling Undead", "hybrid", race_type)) %>%
  mutate(race_type = if_else(race_name == "Underworld Denizens", "agile", race_type)) %>%
  mutate(race_type = if_else(race_name == "Chaos Chosen", "bash", race_type)) %>%
  mutate(race_type = if_else(race_name == "Slann", "agile", race_type)) 
```

From the full dataset, we select four groups of Blood Bowl matches to compare: Three divisions (**Blackbox**, **Ranked** and **League**) that used Blood Bowl 2016 rulesets and were active up until september 2020, and the new **Competitive** division that uses the ruleset from the new Blood Bowl 2020 version of the game ("Second Edition").

I experimented a bit with functional programming using R's `purrr` package, this allows us to write a function and have this function work in parallel on a list of objects, and have it return the results also in list form. For example, here I wrote a function that takes the source data and selects only matches from a particular division:

```{r}
divisions <- c("Competitive", "Blackbox", "Ranked", "Regular_league")

filter_division <- function(div_name){
  df_mbt %>% 
  filter(division_name == div_name) %>%
  filter(race_name != "Treeman") %>%
  filter(race_name != "Simyin")
}

data_tables <- purrr::map(divisions, filter_division)
names(data_tables) <- divisions
```

`data_tables` now contains a list of four datasets, one for each division.

Next step is to select the variables we are interested in.
Again we use the `purrr::map()` function to apply our selection function at once to all four datasets:

```{r}
select_stats <- function(df) {
  df %>% 
  select(race_name, race_type, team_score, away_team_score:away_cas_rip) %>%
  select(-(home_cas_bh:home_cas_rip), -(away_cas_bh:away_cas_rip))
}

data_tables <- map(data_tables, select_stats)
```

We end up with the following set of variables:

```{r}
data_tables$Competitive %>% colnames()
```
# The FUMMBL match statistics

The match statistics that are made available by FUMBBL are all related to important events during Blood Bowl gameplay. 

The most obvious one is **scoring Touchdowns** (`team_score` and `away_team_score`). As this involves getting the ball in the end zone of the opposing player, stats for actions that contribute to scoring such as **passing the ball** are also present. There is the number of **completed passes** (c`home_comp` and `away_comp`) as well as the **net passing distance** (with distance towards the opposing endzone counted positive and counted negative for passes in the opposite direction) (`home_pass` and `away_pass`). As passing is risky, running the ball into the endzone is the most common way to score. For running with the ball FUMBBL has the **rushing** statistic. This name was chosen some 20 years ago, and now may lead to confusion as under the BB2020 rules moving extra squares is called "rushing" (previously called "Going-for-it" or GFI).

The **rushing** statistic is described in a [FUMBBL forum post by SkiJunkie (the author of the predecessor of FUMBBL)](https://www.fumbbl.com/index.php?name=PNphpBB2&file=viewtopic&t=1344&postdays=0&postorder=asc&start=15):
```
running/passing in the wrong direction counts negative. So if you run one step forward then one step back, your net rushing is 0.

Running/passing up and down neither adds nor subtracts. Getting pushed/thrown does not count. 
Only movement made during the players move who has the ball counts.

So, you can end up with negative rushing/passing. 
```

The rushing statistic therefore captures both **ball possession** as well as **the maximum movement of typical ball handlers in each team**. For example, in a Skaven team, the ball is typically handled by Gutter Runners, that have a maximum movement of 9. Compare this to the Dwarf team, where the Dwarf runner only has movement 6. 

Finally, we have the statistics related towards **taking out opposing players**. This involves **blocking**,leading to blocking **casualties**, as well as **fouling** (illegally hitting players that are already down). For blocking, the total number of blocks thrown is tracked (`home_block` and `away_block`), for casualties we have the number of players who suffer a casualty (`home_cas` , `away_cas`) and for fouling we have the number of fouls performed by each team (`home_foul`, `away_foul`). For casualties, we use both the number of casualties **inflicted** as well as casualties **suffered**. This last part is related to the average armour value of a team, that determines the vulnerability of a team against opposing blocks.

As we are interested in statistics at the team level (not for individual matches), we take the average of all the statistics by team:

```{r}
divisions <- c("Competitive", "Blackbox", "Ranked", "Regular_league")

df_agg <- data_tables$Competitive %>% 
  group_by(race_name, race_type) %>% 
  summarise(Blocks = mean(home_block), 
            Completions = mean(home_comp),
            Fouls = mean(home_foul),
            Distance_passed = mean(home_pass), 
            Running_w_ball = mean(home_rush), 
            Cas_inflicted = mean(home_cas),
            Cas_suffered = mean(away_cas), 
            Touchdowns = mean(team_score),
            size = n())

dim(df_agg)
```

This gives us 11 numbers for 28 different BB2020 teams.

# Comparing teams on their match statistics

Now we want to compare the different Blood Bowl teams on their match statistics with each other, and see which races have comparable stats.
If we have only one statistic, it is easy: we can just plot the races on a horizontal line and see which races are closest by.

Lets do that for the **number of blocks made**:

```{r}
options(dplyr.summarise.inform = FALSE)

ggplot(df_agg, aes(x = Blocks, y = 0, size = size, col = race_type)) +
         geom_point() +
scale_size_area()
```
The different colors visualize the Team classification that I added previously based on classifications found online in blog posts, on reddit etc.
We can see that the average number of blocks is already pretty predictive of team type.

But races can be similar if we look at **blocks**, but dissimilar if we look at e.g. **passing**. So lets make a few plots with each plot comparing two different metrics:

```{r}
p1 <- ggplot(df_agg, aes(x = Blocks, y = Completions, size = size, col = race_type)) +
         geom_point() +
  scale_size_area() +
  expand_limits(y=-0.5) +
  geom_label_repel(aes(label = race_name), size  = 2) + theme(legend.position="none")

p2 <- ggplot(df_agg, aes(x = Distance_passed, y = Completions, size = size, col = race_type)) +
         geom_point() +
  scale_size_area() +
  expand_limits(y=-0.5) +
  geom_label_repel(aes(label = race_name), size  = 2) + theme(legend.position="none")
 
p3 <- ggplot(df_agg, aes(x = Running_w_ball, y = Touchdowns, size = size, col = race_type)) +
         geom_point() +
  scale_size_area() +
  expand_limits(y=-0.5) +
  geom_label_repel(aes(label = race_name), size  = 2, force = 5, max.overlaps = 20)   + theme(legend.position="none")
 
p4 <- ggplot(df_agg, aes(x = Distance_passed, y = Fouls, size = size, col = race_type)) +
         geom_point() +
  scale_size_area() +
  expand_limits(y=-0.5) +
  geom_label_repel(aes(label = race_name), size  = 2, max.overlaps = 15) + theme(legend.position="none")

p5 <- ggplot(df_agg, aes(x = Blocks, y = Fouls, size = size, col = race_type)) +
  scale_size_area() +
  expand_limits(y=-0.5) +
  geom_label_repel(aes(label = race_name), size  = 2)  + 
  geom_point() +
  guides(size = "none")
```

```{r warning = F, fig.width = 12}
library(patchwork)

(p1 | p2 | p3)/(p4 |  p5 | plot_spacer()) +   plot_layout(guides = 'collect')
```
Looking at all these plots, we can see that there are clear patterns here. Some are inherently related: Teams that make more passes during a match also cover more passing distance, that is only logical. But there are also patterns that are related to what makes teams different: teams that make more blocks tend to pass less (because they are less good at it). 

Given these patterns, we also see teams that do not conform to the pattern: For example, in the top left plot, the Goblin and Snotling teams tend to make less blocks, but also less passes compared to other teams. And for the top middle plot we see that Halflings are an exception: Given how much they pass, we would expect a higher passing distance. (A quick look at their roster explains this: Halflings have dedicated Catchers (making passing  attractive), but also the Stunty trait, making long distance passes more risky, decreasing the average passing distance).

Finally, which teams are similar depends on which plot we look at! Take for example the Black Orc team: Based on fouling and distance passed (Bottom left plot), it is very similar to the four Stunty teams. However, In the plot that combines Fouls and Blocks (lower right), it suddenly becomes unique!

# PCA versus clustered heatmaps

So how can we compare the teams on all stats simultaneously? We can try to reduce the number of variables by looking at correlations between variables. For example, we observed a strong (negative) correlation between the number of blocks and the number of passes. We could take these two variables together and map ("project") each team on a single new "axis" (the straight line in the top left plot). For this a commonly used technique is PCA ("principal component analysis").  The original variables are combined into "principle components" along which the most variation occurs. [This 2018 nufflytics blog post] (https://www.nufflytics.com/post/bash-dash-hybrid-by-the-numbers/) by **Schlice** applies this technique to classify the Blood Bowl teams of the online **Blood Bowl 2** variant of the game. Another example of this approach is [the master thesis project of Tadas Ivanauskas](https://www.diva-portal.org/smash/get/diva2:1541669/FULLTEXT02.pdf).

With PCA, a common approach is to focus on the first two principal components, as these can be visualized on a 2D coordinate system (i.e. a scatter plot). However, a big disadvantage of PCA is that the new dimensions are difficult to interpret, because the original data is transformed and combined, and therefore no longer recognizable. In the above mentioned blog post, this becomes apparent when the author puts in serious effort to understand the first four principal components, see [his "diving deeper" follow up post](https://www.nufflytics.com/post/bash-dash-hybrid-diving-deeper/). Because each component is a (different) linear combination of ALL 17 variables (!), interpreting the principal components becomes very difficult. To do so requires a high cognitive load, and it is unclear where the signal ends and noise starts.  

An attractive alternative is performing a cluster analysis on the original data, and using the cluster order to directly visualize the data as a heatmap. This technique is called **clustered heatmaps**, and is widely used in bioinformatics to display patterns in data.

Two of the most popular clustering algorithms are **Hierarchical clustering** and **k-means clustering**. For example we can ask the computer to cluster the 28 teams into e.g. 5 clusters using the K-means algorithm. This assigns each team to one of $k = 5$ clusters, with the cluster centers chosen such that teams within a cluster are close by the cluster center and far away from the other cluster centers. However, this forces us to pick the number of clusters, AND it does not provide information on team similarity WITHIN a cluster. 

# Clustered heatmaps for the win

Hierarchical clustering circumvents both drawbacks as it clusters ALL the observations in such a way that the most similar observations end up next to each other, and thus provide a complete ordering of all observations. All that remains is to plot the data in this order on a colored grid, and BAM the patterns hit us right between the eyes!

The basic functionality to make a heatmap is provided in the R package `ggplot2` by the `geom_tile()` geometric object.
There are many wrapper functions around `geom_tile()` to make clustered heatmaps, however they all combine the clustering step with the plotting step.
I am currently experimenting with my own wrapper function `ggorder_heatmap()`, which I turned into an R package called `ggoheatmap`. See for details the GitHub repository for [the ggoheatmap R package](https://github.com/gsverhoeven/ggoheatmap).
Note that it is unstable, under development, and possible not even a good idea, so do not use it yourself.
Instead use `pheatmap` by Raivo Kolde, available from CRAN, with the official repo [here](https://github.com/raivokolde/pheatmap).

```{r}
library(ggoheatmap)
```

```{r}
varnames <- c("Blocks", "Fouls", "Cas_inflicted",  "Distance_passed", "Completions", "Running_w_ball", "Cas_suffered")
yorder <- data.frame(yorder = 1:length(varnames), variable = varnames)

df_long <- df_agg %>%
  pivot_longer(cols = !c(race_name, race_type, size), names_to = "variable") %>%
  group_by(variable) %>%
  mutate(sd_value = scale(value)) %>%
  left_join(yorder, by = "variable")

df_long <- hclust_order(df_long, 
                        xvar = "race_name", 
                        yvar = "variable", 
                        value_var = "value",
                   clust_method = "complete",
                   dist_method = "euclidean")
#df_long
```

```{r}
p1 <- ggplot(df_long, aes(x = reorder(race_name, cluster_order), y = 1, fill = race_type)) +
  geom_tile() + coord_flip() + labs(x = "", y = NULL) + scale_y_discrete(labels = NULL, breaks = NULL) 
#p1
```
From the cluster analysis, Shambling Undead clearly is more similar to hybrid teams than to bash teams.
Khorne is a hybrid team (because of the lack of skills and frenzy reduces base contact and thus blocks).

Also underworld is positioned inbetween Snotling, Goblin and Skaven, and it is in fact a mix of those three teams!!

```{r}
p2 <- ggorder_heatmap(df_long, 
                xvar = "race_name", 
                yvar = "variable", 
                col_var = "sd_value", 
                order_var = "cluster_order",
                yorder_var ="yorder",
                legend = FALSE,
                label_var = "value", round.digits = 1) + coord_flip() +
  scale_y_discrete(position = "right")
```
```{r}
library(patchwork)
```

```{r, fig.width = 12}
p <- p1 + p2 + plot_layout(widths = c(1, 6))

gp <- p + plot_annotation(title = 'BB2020 team typology')

ggsave(filename = "team_typology.png", plot = gp, width = 15, height = 8)

gp
```

```{r fig.width = 12}
source("heatmap_post/make_heatmap.R")

for(i in 1:length(divisions)){
  print(make_heatmap(data_tables[[divisions[i]]], division_name = divisions[i]))
}

```
Slann is agile.

Chaos Chosen twijfelgeval. hebben ook die beastmen.

# Conclusions



# References

http://www.diva-portal.org/smash/get/diva2:1480241/FULLTEXT01.pdf

https://www.diva-portal.org/smash/get/diva2:1541669/FULLTEXT02.pdf

SCHLICE, “Bash/dash/hybrid by the numbers.” https:
//www.nufflytics.com/post/bash-dash-hybrid-by-the-numbers/,
Feb 2018. Accessed on April 2020.


