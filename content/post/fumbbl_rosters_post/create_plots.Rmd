---
title: 'Create plots'
author: "Gertjan Verhoeven"
date: '2023-01-20'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```





# Read and prep the data

We start with reading in the scraped FUMBBL match data, see my previous blog posts mentioned above for details.

```{r warning=FALSE, message=FALSE}
# Load packages
library(tidyverse)
library(ggfortify)
library(ggrepel)
```


# Create heatmap plots for Road to Malta

PM combine in one dataset
PM add new roster and missing roster positions (OWA)

```{r}
df_rosters1 <- read.csv(file = "../../../../fumbbl_datasets/datasets/current/df_rosters_road_to_malta.csv")
df_rosters2 <- read.csv(file = "../../../../fumbbl_datasets/datasets/current/df_rosters_super_league.csv")
df_rosters3 <- read.csv(file = "../../../../fumbbl_datasets/datasets/current/df_rosters_wc_training.csv")

df_rosters1$group_name <- "Road to Malta"
df_rosters2$group_name <- "super_league"
df_rosters3$group_name <- "WC training"

group_name <- "1150K"

df_rosters <- rbind(df_rosters1, df_rosters2, df_rosters3) %>%
  filter(position != "") %>%
  mutate(cnt = 1) %>%
  rename(skill_name = name)
```

```{r}
# add xtra stuff
extra_stuff <- unique(df_rosters %>% 
                    mutate(apothecary = ifelse(apothecary == "Yes", 1, 0)) %>%
  select(group_name, team_id, roster.name, coach_name, rerolls, assistantCoaches, cheerleaders, apothecary) %>%
    pivot_longer(cols = -c(group_name, team_id, roster.name, coach_name), values_to = "cnt") %>%
    filter(cnt > 0) %>%
    mutate(position = name) %>%
    select(group_name, team_id, roster.name, coach_name, position, cnt) %>%
    mutate(player_id = 99999999) %>%
    mutate(number = 99) %>%
    mutate(skill_id = NA) %>%
    mutate(name = NA)) %>%
    rename(skill_name = name)

df_rosters <- df_rosters %>%
  select(-c(X, rerolls, assistantCoaches, cheerleaders, apothecary))

df_rosters <- rbind(df_rosters, extra_stuff)


```

# filter out BB2016 teams (Bretonnian)


```{r}
df_rosters <- df_rosters %>%
  filter(roster.name != "Bretonnian")
```

# PM Label old and new amazon (use Koka Kalim Blitzer as marker for old amazon), and old and new norse rosters

# Check rosters without skills

```{r}
df_rosters %>%
  mutate(w_skill = ifelse(skill_name %in% c("", NA), 0, 1)) %>%
  group_by(group_name, team_id) %>%
  summarise(n_skills = sum(w_skill)) %>%
  mutate(has_skills = ifelse(n_skills == 0, 0, 1)) %>%
  group_by(group_name) %>%
  summarise(perc = mean(has_skills))
```
So the superleague has missing skills.
Hypothesis : teams that only played in round 0 Q2 2022 have missing skills.

Drop teams without skills.

```{r}
teams_to_drop <- df_rosters %>%
  mutate(w_skill = ifelse(skill_name %in% c("", NA), 0, 1)) %>%
  group_by(group_name, team_id) %>%
  summarise(n_skills = sum(w_skill)) %>%
  filter(n_skills == 0) %>%
  pull(team_id)

```
```{r}
df_rosters <- df_rosters %>%
  filter(!(team_id %in% teams_to_drop))
```

# PM wrangle bribes into cnt 0-3 bribes

Cannot easily seperate out the GEt the ref bribes from the  roster bribes

```{r}
# PM remove 15073041 extra row without extra skill
```

# Cleanup the skill names

```{r}
df_rosters <- df_rosters %>%
  mutate(skill_name = str_replace_all(skill_name, 
            pattern = "^_", replacement = "")) %>%
  mutate(skill_name = replace_na(skill_name, ""))
```


# condense skill stacking rows

A player with two skills has two rows, collapse into one, concatenating the two skills.
We sort by skill_id to avoid mirror combinations.

```{r}
df_rosters <- df_rosters %>%
  arrange(player_id, -skill_id) %>%
  group_by(across(c(-skill_id, -skill_name))) %>%
  summarise(skill_name = paste(skill_name, collapse = ""))

```

# create color table

```{r}
library(readODS)

skill_colors <- df_rosters %>%
  group_by(skill_name) %>%
  summarise(n = n())

write_ods(skill_colors, "skill_colors.ods")
```



```{r}
skill_colors <- read_ods("bb_skill_colors.ods")

skill_colors <- skill_colors %>%
  mutate(skill_name = replace_na(skill_name, "")) %>%
  select(-n)
```


# create code list with cost info

create empty list with all roster positions for each race
```{r}

out <- df_rosters %>%
  group_by(position, roster.name) %>%
  summarise(n = n())

```
manually fill in cost and sort order

# add codelist

```{r}
cost <- read_ods("230217_bb_rosters_cost.ods")

cost <- cost %>%
  select(-n)
```

# check for missings

```{r}
out <- out %>% 
  left_join(cost, by = c("position", "roster.name"))

write_ods(out, "bb_rosters.ods")
```


```{r}
df_rosters <- df_rosters %>%
  left_join(cost, by = c("position", "roster.name"))
```

# Check team cost

```{r}


res <- df_rosters %>%
  mutate(tot_cost = cnt * cost) %>%
  group_by(player_id, team_id, position, coach_name, roster.name, tot_cost) %>% # remove two rows per player (skill stacking)
  summarise() %>%
  group_by(team_id, coach_name, roster.name) %>%
  summarise(team_cost = sum(tot_cost)) %>%
  filter(!is.na(team_cost ))

res %>% filter(team_cost > 1150)

```

all teams with 50 or 100 extra, remove 1 bribe ("get the ref" kick off result ends up on the match page)

```{r}
teams_get_the_ref <- res %>%
  filter(team_cost > 1150) %>%
  ungroup() %>%
  distinct(team_id) %>%
  pull()
```

PM this drops ALL bribes

```{r}
# remove the get the ref bribes

df_rosters <- df_rosters %>%
  filter(!(team_id %in% teams_get_the_ref & grepl("bribe", position)))
```

# Check nog een keer de cost

```{r}


res <- df_rosters %>%
  mutate(tot_cost = cnt * cost) %>%
  group_by(player_id, team_id, position, coach_name, roster.name, tot_cost) %>% # remove two rows per player (skill stacking)
  summarise() %>%
  group_by(team_id, coach_name, roster.name) %>%
  summarise(team_cost = sum(tot_cost)) %>%
  filter(!is.na(team_cost ))

summary(res$team_cost)

```

```{r}
res %>% filter(team_cost < 1135)
```


```{r}
df_rosters <- df_rosters %>%
  left_join(skill_colors, by = "skill_name")
```


<!-- TEST CODE FOR CLUSTERING -->
# determine x axis ordering based on clustering

```{r}
  df <- df_rosters %>% 
    filter(roster.name == "Orc") %>%
    filter(!(position %in% c("cheerleaders", "assistantCoaches"))) %>%
    group_by(team_id, coach_name, player_id, position, sort_order, number, skill_name, color) %>% # skill stacking
    summarise(cnt = max(cnt), cost = max(cost)) %>%
    group_by(team_id, coach_name, player_id, position, sort_order, skill_name, color) %>%
    summarise(n = sum(cnt), cost = cost * sum(cnt)) %>%
    group_by(team_id, coach_name, position, sort_order, n) %>%
    summarise(nr = row_number(), skill_name = skill_name, color = color, cost = cost)

df
```
# hclust heeft matrix nodig

matrix met alle mogelijke position-nrs (dus rijen) x coach name, en de cost (0 als missing).

```{r}
df %>% 
  ungroup() %>%
  select(team_id, position, nr, cost) %>%
  pivot_wider(
    names_from = team_id, 
    values_from = cost,
    values_fill = 0,
    values_fn = sum
  ) #%>% select(-position) 
```
Ok, so we have multiple teams per coach, so lets work with coach_name_team_id.

Ready for hierarchical clustering!!

```{r}
library(ggoheatmap)

df_order <- df %>%
  mutate(position_unique = paste0(position, "_", nr)) %>%
  mutate(team_id_char = as.character(team_id)) %>%
  ungroup() %>%
  hclust_order(xvar = "team_id_char", 
               yvar = "position_unique", 
               value_var = "cost", dcast_fill = 1) %>%
  select(team_id, cluster_order) %>%
  distinct() %>%
  right_join(df, by = "team_id")
```

<!-- TEST CODE FOR CLUSTERING -->

# prep data for heatmap

```{r message = F, fig.width= 10}
races <- unique(df_rosters$roster.name)

for(i in 1:length(races)){
  race_name <- races[i]

  df <- df_rosters %>% 
    filter(roster.name == race_name) %>%
    filter(!(position %in% c("cheerleaders", "assistantCoaches"))) %>%
    group_by(team_id, coach_name, player_id, position, sort_order, number, skill_name, color) %>% # skill stacking
    summarise(cnt = max(cnt), cost = max(cost)) %>%
    group_by(team_id, coach_name, player_id, position, sort_order, skill_name, color) %>%
    summarise(n = sum(cnt), cost = cost * sum(cnt)) %>%
    group_by(team_id, coach_name, position, sort_order, n) %>%
    summarise(nr = row_number(), skill_name = skill_name, color = color, cost = cost)

  # check on at least 2 teams
  if(n_distinct(df$team_id) > 1 & n_distinct(df$cost) > 1){ # do clustering
    df <- df %>%
      mutate(position_unique = paste0(position, "_", nr)) %>%
      mutate(team_id_char = as.character(team_id)) %>%
      ungroup() %>%
      hclust_order(xvar = "team_id_char", 
                   yvar = "position_unique", 
                   value_var = "cost", dcast_fill = 1) %>%
      select(team_id, cluster_order) %>%
      distinct() %>%
      right_join(df, by = "team_id") 
  } else {
    df <- df %>%
      mutate(cluster_order = as.integer(as.factor(coach_name)))
  }
  df$coach_team_id <- paste0(df$coach_name, "_", str_sub(as.character(df$team_id), start = -3))
  
  gp <- ggplot(df, aes(x = reorder(factor(coach_team_id), cluster_order), y = reorder(paste(position, nr), -sort_order))) +
    geom_tile(aes(fill = color), color = "black") +
    geom_text(aes(label = n), color = "white") +
    scale_fill_identity(name = "Skills",
                        breaks = c(skill_colors$color),
                        labels = c(skill_colors$skill_name),
                        guide = "legend") +
    #scale_fill_gradient(low = "light blue", high = "blue", na.value = "white") +
    coord_fixed() +
    #theme(legend.position = "none") +
    ggtitle(paste0("FUMBBL ", group_name, " ", race_name, " rosters")) + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    theme(panel.background = element_rect(fill = "white")) +
    labs(x = "Coach_name", y = "")
  
  plotname <- paste0(group_name, " position_plot_", race_name, ".png")
  print(plotname)
  ggsave(plotname, gp, width = 10)
}
```






